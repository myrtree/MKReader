/* ==========================================================================
   Файл: def_code_page.c
   Компилятор: Turbo C 2.0
   Описание: библиотека для автоматического определения кодировки текста
             (ALT, WIN, KOI). Функция m_def_code - для случая, когда текст
             в памяти, функция f_def_code - когда текст в файле.
   Описание алгоритма: http://ivr.webzone.ru/articles/defcod_2/
   (c) Иван Рощин, Москва, 2004.
 ========================================================================= */

#include <stdio.h>
#include "def_code_page.h"

/* Глобальные переменные */

int len_;
unsigned char *p_;

/* Таблица сочетаний */

unsigned char table_2s[128]={0xFF,0xFF,0xFF,0xC7,0xFE,0xBE,0xF7,0xFB,
	0xFD,0xBF,0xF7,0xF9,0xFC,0xBE,0xF1,0x80,0xFF,0xFF,0xF7,0xBB,0xFF,0xFF,0xFF,
	0xCF,0xDE,0xBF,0xD1,0x08,0xFF,0xBF,0xF1,0xBF,0xFF,0xFF,0xFF,0xC7,0x1D,0x3F,
	0x7F,0x81,0xA7,0xB6,0xF2,0x82,0xFF,0xFF,0x75,0xDB,0xFC,0xBF,0xD7,0x9D,0xFF,
	0xAE,0xFB,0xDF,0xFF,0xFF,0xFF,0xC7,0x84,0xB7,0xF3,0x9F,0xFF,0xFF,0xFF,0xDB,
	0xFF,0xBF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC7,0x84,0x9E,0xF0,
	0x12,0xBC,0xBF,0xF0,0x84,0xA4,0xBA,0x10,0x10,0xA4,0xBE,0xB8,0x88,0xAC,0xBF,
	0xF7,0x0A,0x84,0x86,0x90,0x08,0x04,0x00,0x00,0x03,0x7F,0xFD,0xF7,0xC1,0x7D,
	0xAE,0x6F,0xCB,0x15,0x3D,0xFC,0x00,0x7F,0x7D,0xE7,0xC2,0x7F,0xFD,0xF7,0xC3};

/* =========================================================================
   Вспомогательная функция alt2num.
   Вход: a - код русской буквы в кодировке ALT.
   Выход: порядковый номер этой буквы (0-31).
 ========================================================================= */

int alt2num(int a){
	if (a>=0xE0) a-=0x30;
	return (a&31);
}

/* =========================================================================
   Вспомогательная функция koi2num.
   Вход: a - код русской буквы в кодировке KOI.
   Выход: порядковый номер этой буквы (0-31).
 ========================================================================= */

int koi2num(int a){
	static unsigned char t[32]={30,0,1,22,4,5,20,3,21,8,9,10,11,12,13,14,15,31,
		16,17,18,19,6,2,28,27,7,24,29,25,23,26};

	return (t[a&31]);
}

/* =========================================================================
   Вспомогательная функция work_2s - обработка двухбуквенного сочетания.
   Вход:  с1 - порядковый номер первой буквы (0-31),
          c2 - порядковый номер второй буквы (0-31),
          check - надо ли проверять, встречалось ли сочетание раньше
                  (1 - да, 0 - нет),
          buf - адрес массива с информацией о встреченных сочетаниях.
   Выход: 0 - указанное сочетание уже встречалось раньше,
          1 - сочетание не встречалось раньше и является допустимым,
          2 - сочетание не встречалось раньше и является недопустимым.
 ========================================================================= */

int work_2s(int c1, int c2, int check, unsigned char buf[128]){
	int i=(c1<<2)+(c2>>3); /* Номер байта в массиве. */
	int mask=0x80>>(c2&7); /* Маска, соответствующая номеру бита в байте. */

	/* Если check=1, проверяем: если соответствующий бит массива buf равен 0,
	значит, указанное сочетание уже встречалось раньше. Тогда выходим из
	функции, возвращая 0. Если же сочетание не встречалось, то помечаем, что
	оно встретилось (обнуляем соответствующий бит массива buf). */

	if (check==1){
		if ((buf[i]&mask)==0){
			return (0);
		}
		buf[i]&=~mask;
	}

	/* Проверяем, допустимо сочетание или нет. */

	if ((table_2s[i]&mask)!=0){
		return (1); /* Допустимо. */
	}
	return (2);   /* Недопустимо. */
}

/* =========================================================================
   Вспомогательная функция def_code - определение кодировки текста. Функции
   m_def_code и f_def_code - лишь надстройки над этой функцией.
   Вход:  get_char - указатель на функцию, которую надо вызывать для получения
                     очередного символа текста. Функция должна возвращать либо
                     код символа, либо, при достижении конца текста, -1.
          n - количество различных сочетаний русских букв (1-255), которого
              достаточно для определения кодировки.
   Выход: 0 - текст в кодировке ALT, 1 - WIN, 2 - KOI.
 ========================================================================= */

TCodePage def_code(int (*get_char)(), int n){
	/* В массиве buf_1 хранится информация о том, какие сочетания руских букв
	уже встречались в варианте ALT, а в массиве buf_2 - в варианте WIN. */

	unsigned char buf_1 [128];
	unsigned char buf_2 [128];

	int bad_1=0;
	int bad_2=0;
	int bad_3=0;
	int all_1=0;
	int all_3=0;  /* all_2=all_3 */

	int c1; int c2=0; /* Символы текущего обрабатываемого сочетания. */
	int i;

	/* Инициализация buf_1 и buf_2. */

	for (i=0;i<128;i++){
		buf_1[i]=0xFF;
	}
	for (i=0;i<128;i++){
		buf_2[i]=0xFF;
	}

	/* Главный цикл - обработка сочетаний для каждого из трёх вариантов. Цикл
	выполняется, пока не кончится текст или в каком-либо из вариантов не
	встретится n сочетаний. */

	while (((c1=c2,c2=(*get_char)())!=-1)&&(all_1<n)&&(all_3<n)){
		/* Вариант ALT. Вначале проверяем, являются ли символы текущего сочетания
		кодами русских букв в кодировке ALT. */

		if ((((c1>=0x80)&&(c1<0xB0))||((c1>=0xE0)&&(c1<0xF0)))&&
				(((c2>=0x80)&&(c2<0xB0))||((c2>=0xE0)&&(c2<0xF0)))){
			switch (work_2s(alt2num(c1),alt2num(c2),1,buf_1)){ /* Обработали. */
				case 2: bad_1++;
				case 1: all_1++;
			}
		}
		/* Варианты WIN и KOI. Вначале проверяем, являются ли символы текущего
		сочетания кодами русских букв в этих кодировках (в обеих кодировках
		диапазоны кодов русских букв совпадают). */

		if ((c1&c2)>=0xC0){ /* Эквивалентно условию (c1>=0xC0)&&(c2>=0xC0). */
			switch (work_2s(c1&31,c2&31,1,buf_2)){ /* Обработали. */
				case 0: continue; /* Если сочетание букв уже встречалось в варианте WIN,
							то оно уже встречалось и в варианте KOI, так что
							пропускаем обработку варианта KOI и переходим
							к следующей итерации главного цикла. */
				case 2: bad_2++;
			}

			/* Если сочетание букв ещё не встречалось в варианте WIN, то оно заведомо
			не встречалось и в варианте KOI, поэтому специально проверять это не
			надо - значит, функцию work_2s вызываем с параметром check, равным 0. */

			switch (work_2s(koi2num(c1),koi2num(c2),0,NULL)){ /* Обработали. */
				case 2: bad_3++;
				case 1: all_3++;
			}
		}
	}

	/* Данные собраны. Теперь, если в каком-либо из вариантов недопустимых
	сочетаний не больше 1/32 от общего их числа, то считаем, что их и не
	было. */

	if (bad_1<=(all_1>>5)){
		bad_1=0;
	}
	if (bad_2<=(all_3>>5)){
		bad_2=0;
	}
	if (bad_3<=(all_3>>5)){
		bad_3=0;
	}

	/* Получаем результат. */

	{
		unsigned int a=((255-bad_1)<<8)+all_1;
		unsigned int b=((255-bad_2)<<8)+all_3;
		unsigned int c=((255-bad_3)<<8)+all_3;

		if ((a>=b)&&(a>=c)){
			return (CP866);
		}
		if (b>=c){
			return (CP1251);
		}else{
			return (KOI8R);
		}
		return UNKNOWN_CP;
	}
}

/* =========================================================================
   Вспомогательная функция m_get_char вызывается из функции def_code, когда
   та вызвана из m_def_code.
   Выход: очередной символ текста или -1, если текст кончился.
 ========================================================================= */

int m_get_char(){
	if (len_==0){
		return (-1);
	}
	len_--;
	return (*(p_++));
}

/* =========================================================================
   Функция HasBOM - определение юникод-кодировки текста, находящегося в
   памяти, на основе Bytes Order Mark сигнатуры.
   Вход:  p - адрес текста,
   Выход: UTF8 - текст в кодировке UTF8, UTF16BE, UTF16LE, UTF32BE, UTF16LE.
 ========================================================================= */

TCodePage HasBOM(unsigned char *p){
    TCodePage result = UNKNOWN_CP;

    if(sizeof(p) < 4) return result;
    if(p[0] == 0xFF && p[1] == 0xFE)
    {
        if(!p[2] && !p[3]) result = UTF32LE;
        else result = UTF16LE;
    }
    else if(!p[0] && !p[1] && p[2] == 0xFE && p[3] == 0xFF)
        result = UTF32BE;
    else if(p[0] == 0xFE && p[1] == 0xFF)
        result = UTF16BE;
    else if(p[0] == 0xEF && p[1] == 0xBB && p[2] == 0xBF)
        result = UTF8;

    return result;
}

/* =========================================================================
   Функция m_def_code - определение кодировки текста, находящегося в памяти.
   Вход:  p - адрес текста,
          len - длина текста,
          n - количество различных сочетаний русских букв (1-255), которого
              достаточно для определения кодировки.
   Выход: CP866 - текст в кодировке CP866, CP1251, KOI8R,
          UTF8,  UTF16BE,  UTF16LE,  UTF32BE,  UTF16LE.
 ========================================================================= */

TCodePage m_def_code(unsigned char *p, int len, int n){
	int utf16chars = 0;
	int utf16BEchars = 0;
	int utf8chars = 0;
	int i, __len;

    /* Определение кодировки на основе BOM. */
    TCodePage result = HasBOM(p);
    if(result != UNKNOWN_CP){
        return result;
    }

    /* Если BOM нет, то немного вероятностных тестов. */
    __len = (len >= 151) ? 151 : len;
	for (i = 0; i <= __len - 1; i++){
		if (p[i] == 0x00){
		    if (p[i+1] == 0x00)
		    {
		        if ((i % 3) == 0){
                    return UTF32LE;
		        }else{
                    return UTF32BE;
		        }
		    }
			utf16chars++;
			if ((i % 2) == 0){
				utf16BEchars++;
			}
		}else{
			if ((p[i] == 0xD0)||(p[i] == 0xD1)){
				utf8chars++;
			}
		}
	}
	if ((utf16chars > 5)||(utf8chars > 30)){
		if (utf16chars > utf8chars){
			if (utf16BEchars > 3){
				return UTF16BE;
			}else{
				return UTF16LE;
			}
		}else{
			return UTF8;
		}
	}
	/* Присваиваем значения глобальным переменным len_ и p_, которые будут
	доступны из функции m_get_char. */
	len_=len;
	p_=p;
	/* Получаем результат. */
	return (def_code(&m_get_char,n));
}
